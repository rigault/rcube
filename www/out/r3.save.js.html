<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: r3.save.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: r3.save.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* jshint esversion: 6 */

let gribLimits = {
   bottomLat: 0,
   rightLon: 0,
   leftLon: 0,
   topLat: 0,
   name :"",      // wind grib name
   currentName:"" // current grib name
} 
let moduloIsoc = 1;
let gribRectangle = null;
let polarName = "Ultim.csv";
let polWaveName = "polwave.csv";

let competitors = [
  { name: "pistache", lat: 46, lon: -3, color: 0, marker: {}, routePolyline: [] },
  { name: "jojo",     lat: 47, lon: -4, color: 1, marker: {}, routePolyline: [] },
  { name: "titi",     lat: 48, lon: -5, color: 2, marker: {}, routePolyline: [] }
];

/*let competitors = [
  { name: "noname", lat: 46, lon: -3, color: 0, marker: {}, route: [] },
];*/

window.routeParam = {
   iBoat: 1,               // 0 reserved for all boats
   isoStep: 3600,          // 1 h
   startTime: new Date (),
   nTry: 0,                // 0 equivalent to 1 try
   timeStep: 3600,
   timeWindow:0,
   timeInterval: 0,        // 0 means not used
   epochStart: 0,          // Unix time in seconds
   polar: `pol/${polarName}`,
   forbid: "true",
   isoc: "false",
   xWind: 1,
   maxWind: 100,
   penalty0: 0,
   penalty1: 0,
   penalty2: 0,
   motorSpeed: 0,
   threshold: 0,
   dayEfficiency: 1.0,
   nightEfficiency: 1.0,
   cogStep: 5,
   cogRange: 90,
   jFactor: 0,
   kFactor: 1,
   nSectors: 720
}

let rCubeInfo = "© René Rigault";
let index = 0;
const options = {
   key: rCubeKey,
   lat: competitors [0].lat,                                
   lon: competitors [0].lon,
   zoom: 4,
   latlon: true,
   timeControl: true
};
let bounds;
let marker;
let map;
let store;
let destination = null;
let orthoRoute = null;
let orthoRouteGroup;
// tables init
let POIs = [];
let myWayPoints = [];   // contains waypoint up to destination not origin
let route = null;       // global variable storing route
let isochroneLayerGroup;
window.oldRoutes = [];
// Define color mapping based on index
const colorMap = ["red", "green", "blue", "orange", "black"];

// equivalent server side: enum {REQ_TEST, REQ_ROUTING, REQ_BEST_DEP, REQ_RACE, REQ_POLAR, REQ_GRIB, REQ_DIR, REQ_PAR}; // type of request
const REQ = {TEST: 0, ROUTING: 1, BEST_DEP: 2, RACE: 3, POLAR: 4, GRIB: 5, DIR: 6, PAR: 7}; 

const MARKER = encodeURIComponent(`&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?>
        &lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
        &lt;svg width="100%" height="100%" viewBox="0 0 14 14" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421;">
        &lt;path d="M4.784,13.635c0,0 -0.106,-2.924 0.006,-4.379c0.115,-1.502 0.318,-3.151 0.686,-4.632c0.163,-0.654 0.45,-1.623 0.755,-2.44c0.202,-0.54 0.407,-1.021 0.554,-1.352c0.038,-0.085 0.122,-0.139 0.215,-0.139c0.092,0 0.176,0.054 0.214,0.139c0.151,0.342 0.361,0.835 0.555,1.352c0.305,0.817 0.592,1.786 0.755,2.44c0.368,1.481 0.571,3.13 0.686,4.632c0.112,1.455 0.006,4.379 0.006,4.379l-4.432,0Z" style="fill:rgb(0,46,252);"/>&lt;path d="M5.481,12.731c0,0 -0.073,-3.048 0.003,-4.22c0.06,-0.909 0.886,-3.522 1.293,-4.764c0.03,-0.098 0.121,-0.165 0.223,-0.165c0.103,0 0.193,0.067 0.224,0.164c0.406,1.243 1.232,3.856 1.292,4.765c0.076,1.172 0.003,4.22 0.003,4.22l-3.038,0Z" style="fill:rgb(255,255,255);fill-opacity:0.846008;"/>
    &lt;/svg>`);
const MARKER_ICON_URL = `data:image/svg+xml;utf8,${MARKER}`;

const BoatIcon = L.icon ({
   iconUrl: MARKER_ICON_URL,
   iconSize: [24, 24],
   iconAnchor: [12, 12],
   popupAnchor: [0, 0],
});

// --- Chargement depuis localStorage ---
function loadAppState() {
    const savedCompetitors = localStorage.getItem("competitors");
    const savedPolar = localStorage.getItem("polarName");

    if (savedCompetitors) {
        competitors = JSON.parse(savedCompetitors);
    }

    if (savedPolar) {
      polar = savedPolar;
    }

    console.log("Loaded from storage:", competitors, "Polar:", polarName);
}

// --- Sauvegarde dans localStorage ---
function saveAppState() {
    localStorage.setItem("competitors", JSON.stringify(competitors));
    localStorage.setItem("polarName", polar);
}

// --- Reset total (optionnel) ---
function resetAppState() {
    localStorage.removeItem("competitors");
    localStorage.removeItem("polarName");
    location.reload();
}

/**
 * Draw grib limits
 * @param {Object} Grib limis
 */
function drawGribLimits (gribLimits) {
   if (!gribLimits || gribLimits.name == "") return;
   
   if (gribRectangle) {
      map.removeLayer(gribRectangle); // remove former rectangle if exists
   }

   let bounds = [
      [gribLimits.bottomLat, gribLimits.leftLon],
      [gribLimits.topLat, gribLimits.rightLon]
   ];

   gribRectangle = L.rectangle (bounds, {
      color: 'black',
      weight: 2,
      fillOpacity: 0 // only border
   }).addTo(map);

   map.invalidateSize(); // Force Leaflet to recompute drawings
}

/**
 * Draws a polyline on the map using Leaflet.
 *
 * @param {Array&lt;Array&lt;number>>} coords - An array of coordinates where each element is a tuple [latitude, longitude].
 * @param {string} color - The color of the polyline.
 */
function drawPolyline (coords, color) {
   if (!coords || coords.length &lt; 2) return;
   L.polyline(coords, {
      color: color,
      weight: 1,
      opacity: 0.7
   }).addTo(isochroneLayerGroup);
}

/**
 * Show the route of competitor name thanks do data
 *
 * @param {string} The name of the boat
 * @param {Array&lt;Array&lt;number>>} data - 
 */
function showRoute (name, data) {
   console.log(`Boat: ${name}`, data);

   const track = route [name].track;
   // Convert format for Windy (Leaflet)
   const latlngs = track.map(coords => coords.slice(0, 2));
   //console.log (JSON.stringify (latlngs, null, 2));

   const iComp = competitors.findIndex (c => c.name === name); // index of current boat
   if (iComp &lt; 0 ) iComp = 0;
   // Si existe, l'ancienne  route change de couleur
   if (competitors[iComp].routePolyline) {
      ;
      //window.oldRoutes.push(competitors[iComp].routePolyline); // Stocke l'ancienne route
      //competitors[iComp].routePolyline.setStyle({ color: 'pink' });
   }
   const routeColor = colorMap [competitors [iComp].color];
   if (competitors [iComp].routePolyline &amp;&amp; typeof competitors [iComp].routePolyline.remove === 'function')
      competitors [iComp].routePolyline.remove ();
   competitors [iComp].routePolyline = L.polyline (latlngs, {color: routeColor}).addTo(map);
   // alert ("iComp = " + iComp);
   competitors[iComp].marker.setLatLng ([competitors [iComp].lat, competitors [iComp].lon]); // Move the mark
   updateHeading (competitors [iComp], track);
   updateBindPopup (competitors [iComp]);
}

/**
 * Updates the Windy map by displaying the calculated route and optional isochrones.
 *
 * @param {Array&lt;Array&lt;number>>} route - The main sailing route as an array of coordinate pairs [latitude, longitude].
 */
function updateWindyMap (route) {
   const boatName = Object.keys(route)[0]; // Extract first key from response
   if (!route || !route [boatName] || !route [boatName].track) {
      console.error ("Invalid data route !");
      return;
   }
   let isocArray = [];
   if ("_isoc" in route) isocArray = route ["_isoc"];
   
   isochroneLayerGroup.clearLayers ();

   if (Array.isArray (isocArray))
      if (moduloIsoc != 0)
         for (let i = 0; i &lt; isocArray.length; i += 1) 
            if ((i % moduloIsoc) == 0)
               drawPolyline (isocArray [i], "blue");


   competitors.forEach (refreshMarker);
   for (const [name, data] of Object.entries (route)) {
      if (! name.startsWith("_"))
         showRoute (name.trim(), route);
   }

   gribLimits.name = route [boatName].grib;
}

/**
 * Builds the request body for sending data to the server.
 * 
 * @param {string} reqType - The type of request.
 * @param {Array} competitors - List of competitor boats.
 * @param {Array} myWayPoints - List of waypoints as [latitude, longitude].
 * @param {Object} routeParam - Object containing route parameters.
 * @returns {string} The formatted request body.
 */
function buildBodyRequest(reqType, competitors, myWayPoints, routeParam) {
   const waypoints = myWayPoints
      .map(wp => `${wp[0]},${wp[1]}`)
      .join(";");

   // Select the boat(s)
   let boats;
   if (reqType == REQ.RACE) {
      boats = competitors
         .map(c => `${c.name}, ${c.lat}, ${c.lon}`)
         .join(";") + ";";
   } else {
      let c = competitors[routeParam.iBoat - 1];
      console.log("boat: " + `${c.name}, ${c.lat}, ${c.lon}`);
      boats = `${c.name}, ${c.lat}, ${c.lon};`;
   }

   // Define request parameters with safer defaults
   const reqParams = {
      type: reqType,
      boat: boats,
      waypoints: waypoints,
      timeStep: (routeParam.isoStep ?? 3600),
      epochStart: Math.floor(routeParam.startTime.getTime() / 1000),
      polar: `pol/${polarName}`,
      wavePolar: `wavepol/${polWaveName}`,
      forbid: (routeParam.forbid ?? "true"),
      isoc: (routeParam.isoc ?? "false"),
      withWaves: (routeParam.withWaves ?? "false"),
      withCurrent: (routeParam.withCurrent ?? "false"),
      timeWindow: (routeParam.nTry ?? 0) * (routeParam.timeInterval ?? 0),
      timeInterval: (routeParam.timeInterval ?? 0),
      xWind: isNaN(routeParam.xWind ?? NaN) ? 1 : routeParam.xWind,
      maxWind: isNaN(routeParam.maxWind ?? NaN) ? 100 : routeParam.maxWind,
      penalty0: isNaN(routeParam.penalty0 ?? NaN) ? 0 : routeParam.penalty0,
      penalty1: isNaN(routeParam.penalty1 ?? NaN) ? 0 : routeParam.penalty1,
      penalty2: isNaN(routeParam.penalty2 ?? NaN) ? 0 : routeParam.penalty2,
      motorSpeed: isNaN(routeParam.motorSpeed ?? NaN) ? 0 : routeParam.motorSpeed,
      threshold: isNaN(routeParam.threshold ?? NaN) ? 0 : routeParam.threshold,
      dayEfficiency: isNaN(routeParam.dayEfficiency ?? NaN) ? 1.0 : routeParam.dayEfficiency,
      nightEfficiency: isNaN(routeParam.nightEfficiency ?? NaN) ? 1.0 : routeParam.nightEfficiency,
      cogStep: isNaN(routeParam.cogStep ?? NaN) ? 5 : routeParam.cogStep,
      cogRange: isNaN(routeParam.cogRange ?? NaN) ? 90 : routeParam.cogRange,
      jFactor: isNaN(routeParam.jFactor ?? NaN) ? 0 : routeParam.jFactor,
      kFactor: isNaN(routeParam.kFactor ?? NaN) ? 1 : routeParam.kFactor,
      nSectors: isNaN(routeParam.nSectors ?? NaN) ? 720 : routeParam.nSectors
   };

   let requestBody = Object.entries(reqParams)
      .map(([key, value]) => `${key}=${value}`)
      .join("&amp;");
   
   if (gribLimits.name &amp;&amp; typeof gribLimits.name === "string" &amp;&amp; gribLimits.name.trim().length > 1) {
      requestBody += `&amp;grib=grib/${gribLimits.name}`;
      if (gribLimits.currentName.trim().length > 1)
         requestBody +=`&amp;currentGrib=currentgrib/${gribLimits.currentName}`;
   }
   
   return requestBody;
}

/**
 * Constructs and prepares the request body for a routing API call.
 *
 * This function gathers waypoints, selects the request type, formats boat data, 
 * and calculates time parameters before building the request string.
 */
function request () {
   if (myWayPoints == null || myWayPoints == undefined || myWayPoints.length === 0) {
      Swal.fire({
         icon: "error",
         title: "Invalid Request",
         text: "No waypoints or destination defined.",
         confirmButtonText: "OK"
      });
      return;
   }
   
   const reqType = (routeParam.iBoat == 0) ? REQ.RACE : (routeParam.nTry > 1) ? REQ.BEST_DEP: REQ.ROUTING; 
   let requestBody = buildBodyRequest (reqType, competitors, myWayPoints, routeParam);
   console.log ("request: " + requestBody);
   const spinnerOverlay = document.getElementById ("spinnerOverlay");
   spinnerOverlay.style.display = "flex"; // display spinner

   fetch (apiUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: requestBody
   })
   .then(response => response.json().catch(() => { 
       throw new Error ("Invalid JSON response from server");
   })) // Always attempt to parse JSON, even on error responses
   .then(data => {
      console.log(JSON.stringify(data, null, 2));

      const firstKey = Object.keys(data)[0]; // Extract first key from response
      
      if (firstKey.startsWith("_")) {  // If the server returned an error or warning
         Swal.fire({
            title: "Warning",
            text: firstKey + ": " + data [firstKey],
            icon: "warning",
            confirmButtonText: "OK"
         });

         gribLimits.bottomLat = data.bottomLat || gribLimits.bottomLat;
         gribLimits.leftLon = data.leftLon || gribLimits.leftLon;
         gribLimits.topLat = data.topLat || gribLimits.topLat;
         gribLimits.rightLon = data.rightLon || gribLimits.rightLon;
         gribLimits.name = data.grib || gribLimits.name;
         drawGribLimits (gribLimits);
         return; // Stop further processing
      }
      route = data;
      const boatName = firstKey;

      // Normal processing of response
      switch (reqType) {
         case REQ.RACE:
            displayComp (route);
            break;
         case REQ.BEST_DEP:
            displayBestTimeHistogram (route, routeParam.startTime);
            break;
         case REQ.ROUTING:
            // alert ("boatName: " + boatName);
            showRouteReport (route, routeParam.startTime);
            break;
         default:
            break;
      }
      const iComp = competitors.findIndex (c => c.name === boatName); // index of current boat
      //competitors [iComp].route = route; // save route in competitir object
      //alert ("competitor: " + competitors [iComp].name);
      goBegin ();
      updateWindyMap (route);

      gribLimits.bottomLat = route [firstKey]?.bottomLat || gribLimits.bottomLat;
      gribLimits.leftLon = route [firstKey]?.leftLon || gribLimits.leftLon;
      gribLimits.topLat = route [firstKey]?.topLat || gribLimits.topLat;
      gribLimits.rightLon = route [firstKey]?.rightLon || gribLimits.rightLon;
      gribLimits.name = route [firstKey]?.grib || gribLimits.name;

      drawGribLimits (gribLimits);
      updateStatusBar (route);
   })
   .catch(error => {
      console.error("Fetch error:", error);
      Swal.fire({
         icon: "error",
         title: "Request Failed",
         text: "The server is not responding or returned an invalid response.",
         confirmButtonText: "OK"
      });
   })
   .finally(() => {
      spinnerOverlay.style.display = "none";
   });
}

/**
 * Computes the great-circle path (orthodromic route) between two geographical points.
 *
 * This function calculates a series of intermediate points along the shortest path
 * between two locations on the Earth's surface, using spherical interpolation.
 *
 * @param {number} lat0 - Latitude of the starting point, in degrees.
 * @param {number} lon0 - Longitude of the starting point, in degrees.
 * @param {number} lat1 - Latitude of the destination point, in degrees.
 * @param {number} lon1 - Longitude of the destination point, in degrees.
 * @param {number} [n=100] - Number of intermediate points to compute along the path.
 * @returns {Array&lt;Array&lt;number>>}  The great-circle path as an array of coordinate pairs [latitude, longitude].
 */
function getGreatCirclePath (lat0, lon0, lat1, lon1, n = 100) {
   let path = [];
   let φ1 = (lat0 * Math.PI) / 180;
   let λ1 = (lon0 * Math.PI) / 180;
   let φ2 = (lat1 * Math.PI) / 180;
   let λ2 = (lon1 * Math.PI) / 180;

   for (let i = 0; i &lt;= n; i++) {
      let f = i / n;
      let A = Math.sin((1 - f) * Math.acos(Math.sin(φ1) * Math.sin(φ2) + Math.cos(φ1) * Math.cos(φ2) * Math.cos(λ2 - λ1)));
      let B = Math.sin(f * Math.acos(Math.sin(φ1) * Math.sin(φ2) + Math.cos(φ1) * Math.cos(φ2) * Math.cos(λ2 - λ1)));

      let x = A * Math.cos(φ1) * Math.cos(λ1) + B * Math.cos(φ2) * Math.cos(λ2);
      let y = A * Math.cos(φ1) * Math.sin(λ1) + B * Math.cos(φ2) * Math.sin(λ2);
      let z = A * Math.sin(φ1) + B * Math.sin(φ2);

      let φ = Math.atan2(z, Math.sqrt(x * x + y * y));
      let λ = Math.atan2(y, x);

      path.push([φ * (180 / Math.PI), λ * (180 / Math.PI)]);
   }
   return path;
}

/**
 * Draws both the loxodromic orthodromic (great-circle) routes 
 * for a given competitor and waypoints.
 *
 * This function extracts the competitor's starting position, and prepares the orthodromic route.
 *
 * @param {Object} competitors - competitor is an aovject containing at least name, lat, lon.
 * @param {Array&lt;Array&lt;number>>} myWayPoints - Array of waypoints as [latitude, longitude] pairs.
 */
function drawOrtho (competitor, myWayPoints) {
   if (!competitor) {
      console.error("Invalid data for competitor.");
      return;
   }
   // extract lat and lon of specified competitor
   let firstPoint = [competitor.lat, competitor.lon];

   // build table of points 
   let routePoints = [firstPoint, ...myWayPoints];
   console.log ("routePoints:", routePoints);
   console.log ("routePoints:", routePoints);

   //orthoRouteGroup.clearLayers();
   // Create orthodromie
   routePoints.forEach ((wp, index) => {
      if (index &lt; routePoints.length - 1) {
         let lat0 = wp [0], lon0 = wp [1];
         let lat1 = routePoints [index + 1][0], lon1 = routePoints[index + 1][1];

         let path = getGreatCirclePath (lat0, lon0, lat1, lon1, 100);
         let polyline = L.polyline (path, { color: 'green', weight: 3, dashArray: '5,5' });

         // Ajoute la polyligne au groupe au lieu de l'écraser
         orthoRouteGroup.addLayer (polyline);
      }
   });
}

/**
 * Adds a Point of Interest (POI) at the specified latitude and longitude.
 * This function prompts the user to enter a name for the POI using SweetAlert,
 * then adds it to the `POIs` list and places a marker on the map.
 *
 * @param {number} lat - Latitude of the POI.
 * @param {number} lon - Longitude of the POI.
 */
function addPOI (lat, lon) {
   Swal.fire({
      title: "POI",
      input: "text",
      inputPlaceholder: "Name",
      showCancelButton: true,
      confirmButtonText: "Add",
      cancelButtonText: "Cancel",
      inputValidator: (value) => {
         if (!value) {
            return "Name cannot be empty";
         }
      }
   }).then((result) => {
      if (result.isConfirmed) {
         POIs.push({ lat, lon, name });
         console.log("POIs: ", POIs);
         L.marker([lat, lon]).addTo(map).bindPopup (`POI: ${name}`).openPopup();
      }
   });
   closeContextMenu();
}

/**
 * Clears all routes, waypoints, and markers from the map.
 * This function resets the waypoints list, removes all layers and polylines,
 * and clears markers for the destination and computed routes.
 */
function clearRoutes () {
   isochroneLayerGroup.clearLayers();
   // Delete old routes
   //window.oldRoutes.forEach(route => route.remove());
   //window.oldRoutes = [];
   competitors.forEach(comp => {
      if (comp.routePolyline &amp;&amp; typeof comp.routePolyline.remove === 'function') {
         comp.routePolyline.remove();
        // comp.routePolyline = null;
      }
   });
   route = null;
   index = 0;
   competitors.forEach (refreshMarker);
}

/**
 * Resets all waypoints and clears related map elements.
 * This function removes all stored waypoints, clears the loxodromic 
 * and orthodromic routes, and removes the destination marker if it exists.
 */
function resetWaypoint () {
   myWayPoints = [];
   orthoRouteGroup.clearLayers();
   if (destination) destination.remove ();
}

/**
 * Updates the boat's position to the specified latitude and longitude.
 * This function moves the selected competitor to the given coordinates,
 * updates its map marker, and redraws the loxodromic and orthodromic routes.
 * If waypoints exist, it also updates the boat's heading.
 *
 * @param {Object} competitor is an object containing at least name, latitude, longitude.
 * @param {number} index - Index of the competitor to update in the `competitors` array.
 * @param {number} lat - New latitude of the boat.
 * @param {number} lon - New longitude of the boat.
 */
function setBoat (competitor, lat, lon) {
   competitor.lat = lat;
   competitor.lon = lon;

   competitor.marker.setLatLng ([lat, lon]);                   // Move the mark

   console.log("Waypoints:", myWayPoints);
   drawOrtho (competitor, myWayPoints);

   if (myWayPoints.length > 0) {
      let heading = orthoCap([lat, lon], myWayPoints[0]);
      competitor.marker._icon.setAttribute ('data-heading', heading);
      updateIconStyle (competitor.marker);
   }
   closeContextMenu();
   orthoRouteGroup.clearLayers();
   for (let boat of competitors)
      drawOrtho (boat, myWayPoints);
   saveAppState();
}

/**
 * Add destination at the specified latitude and longitude.
 *
 * @param {number} lat - Latitude of the destination.
 * @param {number} lon - Longitude of the destination.
 */
function showDestination (lat, lon) {
   if (destination) destination.remove();
   destination = L.marker([lat, lon], {
      icon: L.divIcon({
         className: 'custom-destination-icon',
         html: '🏁',
         iconSize: [32, 32],
         iconAnchor: [8, 16]
      })
   }).addTo(map);
}

/**
 * Adds a new waypoint at the specified latitude and longitude.
 * This function appends a new waypoint to `myWayPoints`. If it is the first waypoint, 
 * it also updates the boat's heading toward this point.
 *
 * @param {number} lat - Latitude of the new waypoint.
 * @param {number} lon - Longitude of the new waypoint.
 */
function addWaypoint (lat, lon) {
   if (myWayPoints.length == 0) {
      for (let boat of competitors) {
         // position heading of boat at first waypoint
         let heading = orthoCap([boat.lat, boat.lon], [lat, lon]);
         boat.marker.setLatLng ([boat.lat, boat.lon]);                   // Move the mark
         boat.marker._icon.setAttribute('data-heading', heading); 
         updateIconStyle (boat.marker);
      }
   }

   myWayPoints.push ([lat, lon]);
   for (let boat of competitors)
      drawOrtho (boat, myWayPoints);
   showDestination (lat, lon);
   console.log ("Waypoints:", myWayPoints);
   closeContextMenu();
}

/**
 * Updates the icon rotation based on the boat's heading.
 * This function checks if a marker exists and retrieves its heading attribute.
 * If the icon does not already have a rotation applied, it modifies the CSS `transform` property 
 * to rotate the marker according to its heading.
 */
function updateIconStyle (marker) {
   if (!marker) return;
   const icon = marker._icon;
   if (!icon) return;
   const heading = marker._icon.getAttribute('data-heading');
   if (icon.style.transform.indexOf ('rotateZ') === -1) {
      icon.style.transform = `${
         icon.style.transform
      } rotateZ(${heading}deg)`;
      icon.style.transformOrigin = 'center';
   }
}

/**
 * Moves the boat along its track by a given step.
 * This function updates the boat's position based on the given track and step count.
 * It adjusts the index within valid bounds, updates the boat's marker position, 
 * and updates the Windy map timestamp accordingly.
 *
 * @param {Array&lt;Array&lt;number>>} firstTrack - The array of waypoints, where each waypoint is [latitude, longitude].
 * @param {number} n - The step count to move forward (positive) or backward (negative).
 */
function move (iComp, firstTrack, index) {
   if (index >= firstTrack.length) {
      return;
   }
   if (index &lt; 0) {
      index = firstTrack.length - 1;
   }
   let time = new Date(routeParam.startTime.getTime() + index * routeParam.isoStep * 1000);
   //alert ("avant");
   let newLatLng = firstTrack[index].slice(0, 2);     // New position
   console.log ("move: ", iComp, "time: " + time);
   competitors [iComp].marker.setLatLng (newLatLng);  // Move the mark

   // Center map on new boat position
   // map.setView(newLatLng, map.getZoom());
   store.set ('timestamp', time);                  // update Windy time
   updateHeading (competitors [iComp], firstTrack);
}

/**
 * Update bind popup
 */
function updateBindPopup (competitor) {
   const I_SOG = 2; I_HDG = 5;
   let sog = route [competitor.name].track [index][I_SOG];
   let hdg = route [competitor.name].track [index][I_HDG];
   hdg = (360 + hdg) % 360;
   // alert ("updateBindPopup name: " + competitor.name);
   if (sog != undefined)
      competitor.marker.bindPopup (`${competitor.name}&lt;br>${hdg.toFixed(0)}° ${sog.toFixed(2)} kn`);
}

/**
 * Updates the boat's heading based on its current and next position.
 * This function calculates the bearing (heading) between the current position and 
 * the next point in the track, and updates the boat's marker rotation.
 *
 * @param {Array&lt;Array&lt;number>>} firstTrack - The array of waypoints, where each waypoint is [latitude, longitude].
 */
function updateHeading (competitor, firstTrack) {
   let heading;
   if (index &lt; firstTrack.length - 1)
      heading = orthoCap (firstTrack[index].slice(0, 2), firstTrack[index + 1].slice(0, 2));
   else
      heading = orthoCap(firstTrack[index-1], firstTrack[index].slice(0, 2));
   competitor.marker._icon.setAttribute('data-heading', heading);
   updateIconStyle (competitor.marker);
}

/**
 * Common part of goBegin, backWard and forWard.
 * This function calls move for all relevant competitors 
 */
function updateAllBoats () {
   if (!route) 
      return;
   const boatNames = Object.keys(route);
   console.log ("boatNames:", boatNames);
   boatNames.forEach((name, i) => {
      let iComp = competitors.findIndex (c => c.name === name); // index of current boat
      if ((iComp >= 0) &amp;&amp; (! name.startsWith("_"))) {
         console.log ("boatName: ", name, "iComp = ", iComp);
         move (iComp, route[name].track, index);
      }
   });
}

/**
 * Resets the boat's position to the beginning of its track.
 * This function sets the index to 0 and moves the boat to the first waypoint,
 * ensuring time and position are updated accordingly.
 */
function goBegin () {
   index = 0;
   updateAllBoats ();
}

/**
 * Moves the boat one step backward along its track.
 * Calls `move()` with a negative step value to shift the boat to the previous waypoint.
 */
function backWard () {
   index -= 1;
   updateAllBoats ();
}

/**
 * Moves the boat one step forward along its track.
 * Calls `move()` with a positive step value to shift the boat to the next waypoint.
 */
function forWard () {
   index += 1;
   updateAllBoats ();
}

/**
 * Formats a date into a human-readable string with the weekday, date, and local time.
 * Example output: "Saturday, 2025-03-08 22:44 Local Time"
 *
 * @param {Date} date - The date object to format.
 * @returns {string} The formatted date string.
 */
function formatLocalDate (date) {
    // Get individual date components
    const dayName = date.toLocaleString('en-US', { weekday: 'long' });
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0'); // Ensure two-digit format
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');

    return `${dayName}, ${year}-${month}-${day} ${hours}:${minutes} Local Time`;
}

/**
 * Updates status bar information and calculates bounds.
 * If no route is provided, it updates general parameters such as the polar name and GRIB file.
 *
 * @param {Object|null} [route=null] - The route object containing navigation data, or `null` to update global info.
 */
function updateStatusBar (route = null) {
   findBounds (myWayPoints);
   let time = "";
   let polar = "", wavePolar = "", grib = "", currentGrib = "";
   if (route === null) {
      polar = polarName;
      wavePolar = polWaveName;
      grib = gribLimits.name;
      currentGrib = gribLimits.currentName;
   }
   else if (route) {
      const boatName = Object.keys(route)[0]; // Extract first key from response
      polar = route[boatName].polar;
      wavePolar = route[boatName].wavePolar;
      grib = route[boatName].grib;
      currentGrib = route[boatName].currentGrib;
      time = formatLocalDate (new Date (routeParam.startTime.getTime() + index * routeParam.isoStep * 1000));
   }
   document.getElementById("infoRoute").innerHTML = "";
   if (time.length > 0) document.getElementById("infoTime").innerHTML = "📅 " + time; 
   if (polar.length > 0) document.getElementById("infoRoute").innerHTML += "    ⛵ polar: " + polar; 
   if (wavePolar.length > 0) document.getElementById("infoRoute").innerHTML += "    🌊 wavePolar: " + wavePolar;
   if (grib.length > 0) document.getElementById("infoRoute").innerHTML += "    💨 Grib: " + grib;
   if (currentGrib.length > 0) document.getElementById("infoRoute").innerHTML += "    🔄 currentGrib: " + currentGrib;
}

/**
 * Determines the bounding box for a given set of waypoints.
 *
 * This function calculates the minimum and maximum latitude/longitude values 
 * to define the bounding box that encloses the route.
 *
 * @param {Array&lt;Array&lt;number>>} wayPoints - An array of waypoints as [latitude, longitude] pairs.
 */
function findBounds (wayPoints) {
   if (wayPoints.length &lt; 2) return;
   let lat0 = wayPoints [0][0];
   let lat1 = wayPoints [wayPoints.length - 1][0];
   let lon0 = wayPoints [0][1];
   let lon1 = wayPoints [wayPoints.length - 1][1];
   
   bounds = [
      [Math.floor (Math.min (lat0, lat1)), Math.floor (Math.min (lon0, lon1))],  // Inf left
      [Math.ceil (Math.max (lat0, lat1)), Math.ceil (Math.max (lon0, lon1))]     // Sup right
   ];
   console.log ("bounds: " + bounds);
} 

/**
 * Closes the existing context menu if it is present on the page.
 *
 * This function removes the context menu from the document if it exists,
 * preventing multiple menus from stacking.
 */
function closeContextMenu() {
    let oldMenu = document.getElementById("context-menu");
    if (oldMenu) {
        document.body.removeChild(oldMenu);
    }
}

/**
 * Displays a custom context menu at the mouse click position.
 *
 * This function retrieves the latitude and longitude from the event,
 * creates a new context menu element, and positions it based on the 
 * mouse's screen coordinates.
 *
 * @param {Object} e - The event object containing the click position and map coordinates.
 * @param {Object} e.latlng - The latitude and longitude of the clicked point.
 * @param {number} e.latlng.lat - The latitude of the clicked location.
 * @param {number} e.latlng.lng - The longitude of the clicked location.
 * @param {Object} e.originalEvent - The original DOM event containing screen coordinates.
 * @param {number} e.originalEvent.clientX - The X coordinate of the click event on the screen.
 * @param {number} e.originalEvent.clientY - The Y coordinate of the click event on the screen.
 */
function oldshowContextMenu(e) {
    // e.preventDefault(); // optionnel
    closeContextMenu(); // Fermer le menu précédent

    const lat = e.latlng.lat.toFixed(6);
    const lon = e.latlng.lng.toFixed(6);

    let menu = document.createElement("div");
    menu.id = "context-menu";
    menu.style.top = `${e.originalEvent.clientY}px`;
    menu.style.left = `${e.originalEvent.clientX}px`;

    // Générer les boutons pour chaque compétiteur avec couleur
    let buttons = competitors.map((c, index) => {
        const color = colorMap[c.color % colorMap.length]; // Sécurité : modulo taille du tableau
        return `&lt;button class="context-button" style="border-left: 6px solid ${color}; padding-left: 8px;" onclick="setBoat(competitors[${index}], ${lat}, ${lon})">Set ${c.name}&lt;/button>`;
    }).join("");

    // Ajoute une séparation visuelle
    buttons += `&lt;hr style="margin: 6px 0;">`;

    // Ajouter les autres options
    buttons += `
        &lt;button class="context-button" onclick="addWaypoint(${lat}, ${lon})">Add Waypoint or Destination&lt;/button>
        &lt;button class="context-button" onclick="resetWaypoint()">Reset Waypoints and Destination&lt;/button>
        &lt;button class="context-button" onclick="addPOI(${lat}, ${lon})">Add POI&lt;/button>
    `;

    menu.innerHTML = buttons;
    document.body.appendChild(menu);

    document.addEventListener("click", closeContextMenu, { once: true });
}

function showContextMenu(e) {
    closeContextMenu();

    const lat = e.latlng.lat.toFixed(6);
    const lon = e.latlng.lng.toFixed(6);

    let menu = document.createElement("div");
    menu.id = "context-menu";
    menu.style.top = `${e.originalEvent.clientY}px`;
    menu.style.left = `${e.originalEvent.clientX}px`;

    // Boutons pour chaque compétiteur avec cercle coloré
    let buttons = competitors.map((c, index) => {
        const color = colorMap[c.color % colorMap.length];
        return `
            &lt;button class="context-button" onclick="setBoat(competitors[${index}], ${lat}, ${lon})">
                &lt;span class="color-dot" style="background-color: ${color};">&lt;/span>
                Set ${c.name}
            &lt;/button>
        `;
    }).join("");

    buttons += `&lt;hr style="margin: 6px 0;">`;

    buttons += `
        &lt;button class="context-button" onclick="addWaypoint(${lat}, ${lon})">Add Waypoint or Destination&lt;/button>
        &lt;button class="context-button" onclick="resetWaypoint()">Reset Waypoints and Destination&lt;/button>
        &lt;button class="context-button" onclick="addPOI(${lat}, ${lon})">Add POI&lt;/button>
    `;

    menu.innerHTML = buttons;
    document.body.appendChild(menu);

    document.addEventListener("click", closeContextMenu, { once: true });
}

/**
 * Updates the boat's position and marker based on the selected timestamp from Windy.
 *
 * This function calculates the corresponding index in the route data based on 
 * the selected timestamp, updates the boat's position, and moves the marker accordingly.
 *
 * @param {number} selectedTimestamp - The selected timestamp (in seconds) from Windy's timeline.
 */
function updateRouteDisplay (selectedTimestamp) {
   //const boatName = Object.keys(route)[0]; // Extract first key from response
   console.log ('Met à jour la route pour la date :', new Date(selectedTimestamp * 1000).toISOString());
   if (! route) return;
   //let firstTrack = route [boatName].track;

   let startTimeSec = Math.floor(routeParam.startTime.getTime() / 1000);
   index = Math.round((selectedTimestamp - startTimeSec) / routeParam.isoStep);
   console.log ("index avant: " + index);
   
   //if (index >= firstTrack.length) index = firstTrack.length - 1;
   //else 
   if (index &lt; 0) index = 0;
   console.log ("index apres: " + index);

   const boatNames = Object.keys(route);
   console.log ("boatNames:", boatNames);
   boatNames.forEach((name, i) => {
      let iComp = competitors.findIndex (c => c.name === name); // index of current boat
      if ((iComp >= 0) &amp;&amp; (! name.startsWith("_"))) {
         let track = route [name].track;
         // console.log ("boatName: ", name, "iComp = ", iComp, "track = " + track);
         if (index &lt; track.length) {
            let newLatLng = track [index].slice (0, 2); // New position
            competitors [iComp].marker.setLatLng (newLatLng);                   // Move the mark
            if (index != track.length -1) updateHeading (competitors [iComp], track);
            updateStatusBar (route);
            updateBindPopup (competitors [iComp]);
         }
      }
   });
}

/**
 * Add a marker to competitor
 * @param {Object} competitor with at least name, lat, lon
 * @param {number} index of competitor.
 */
function addMarker (competitor, iComp) {
   let marker = L.marker([competitor.lat, competitor.lon], {
      icon: BoatIcon,
   }).addTo(map);
   marker.bindPopup(competitor.name);
   // Ouvrir seulement pour le premier concurrent
   if (iComp === 0) {
      marker.openPopup();
   }

   competitor.marker = marker;
}

/**
 * Recreate a marker for competitor
 * @param {Object} competitor with at least name, lat, lon
 * @param {number} index of competitor.
 */
function refreshMarker (competitor, iComp) {
   if (competitor.marker)
      competitor.marker.remove ();
   let marker = L.marker([competitor.lat, competitor.lon], {
      icon: BoatIcon,
   }).addTo(map);
   marker.bindPopup(competitor.name);
   competitor.marker = marker;
   if (myWayPoints.length > 0) {
      let heading = orthoCap([competitor.lat, competitor.lon], myWayPoints [0]);
      competitor.marker._icon.setAttribute('data-heading', heading); 
      updateIconStyle (competitor.marker);
   }
}

/**
 * Initializes the Windy API and retrieves the map and store objects.
 *
 * This function initializes the Windy API with the given options and assigns the 
 * `windy`, `map`, and `store` objects for further interactions.
 *
 * @param {Object} options - Configuration options for Windy API initialization.
 * @param {function(Object): void} callback - Callback function that receives the Windy API instance.
 */
windyInit (options, windyAPI => {
   windy = windyAPI;
   map = windy.map;
   store = windy.store;
   //map.fitBounds (bounds); // ajust recenter

   // Correct initial date &amp; time
   let initialTimestamp = store.get ('timestamp');
   if (initialTimestamp > 1e10) {
      initialTimestamp = Math.floor (initialTimestamp / 1000);
   }
   updateRouteDisplay (initialTimestamp); // update initial display

   competitors.forEach (addMarker); // show initial position of boats

   // Listen to timestamp changes
   store.on ('timestamp', (newTimestamp) => {
      if (newTimestamp > 1e10) {
         newTimestamp = Math.floor(newTimestamp / 1000);
      }
      updateRouteDisplay (newTimestamp);
   });

   isochroneLayerGroup = L.layerGroup().addTo(map);
   orthoRouteGroup = L.layerGroup().addTo(map);
   
   map.on ("contextmenu", showContextMenu);	

   let isContextMenuOpen = false; // Avoid multiple display

   document.addEventListener("touchstart", function (event) {
      if (isContextMenuOpen) return; // Do not open several contect menus
         let touch = event.touches [0];

	   // check if userr touch &lt;header>, #tool ou &lt;footer>
      let targetElement = event.target.closest("header, #tool, footer");
      if (targetElement) return; // Ignore one of these elem

      let timeout = setTimeout (() => {
         let latlng = map.containerPointToLatLng([touch.clientX, touch.clientY]);
         isContextMenuOpen = true; // Avoid multiple display
         let fakeEvent = {
            latlng: latlng,
            originalEvent: {
               clientX: touch.clientX,
               clientY: touch.clientY
            }
         };

         showContextMenu (fakeEvent)

         // Authorize menu again after close
         document.addEventListener("click", () => {
            isContextMenuOpen = false;
         }, { once: true });

      }, 500); // 500 ms => long touch

      document.addEventListener("touchmove", function () {
         clearTimeout(timeout); // Annuler si l'utilisateur bouge
      }, { passive: true });

   }, { passive: true });

   map.on ('mousemove', function (event) {
        let lat = event.latlng.lat; //
        let lon = event.latlng.lng; 
        document.getElementById ('coords').textContent = toDMSString (lat, lon);
    });
   // Handle some events. We need to update the rotation of icons ideally each time
   // leaflet re-renders. them.

   map.on("zoomend", function () {
      competitors.forEach(function (competitor) {
         updateIconStyle(competitor.marker);
      });
      drawGribLimits(gribLimits);
   });
   map.on("zoom", function () {
      competitors.forEach(function (competitor) {
         updateIconStyle(competitor.marker);
      });
      drawGribLimits (gribLimits);
   });
   map.on ("viewreset", function () {
      competitors.forEach(function (competitor) {
         updateIconStyle(competitor.marker);
      });
      drawGribLimits (gribLimits);
   });
   loadAppState ();
   getServerInit ();
   updateStatusBar ();
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#addCompetitor">addCompetitor</a></li><li><a href="global.html#addMarker">addMarker</a></li><li><a href="global.html#addPOI">addPOI</a></li><li><a href="global.html#addWaypoint">addWaypoint</a></li><li><a href="global.html#backWard">backWard</a></li><li><a href="global.html#bestVmg">bestVmg</a></li><li><a href="global.html#bestVmgBack">bestVmgBack</a></li><li><a href="global.html#buildBodyRequest">buildBodyRequest</a></li><li><a href="global.html#changeParam">changeParam</a></li><li><a href="global.html#chooseGrib">chooseGrib</a></li><li><a href="global.html#choosePolar">choosePolar</a></li><li><a href="global.html#clearRoutes">clearRoutes</a></li><li><a href="global.html#closeContextMenu">closeContextMenu</a></li><li><a href="global.html#condenseTimeStamps">condenseTimeStamps</a></li><li><a href="global.html#deleteAllPOIs">deleteAllPOIs</a></li><li><a href="global.html#deletePOI">deletePOI</a></li><li><a href="global.html#displayBestTimeHistogram">displayBestTimeHistogram</a></li><li><a href="global.html#displayComp">displayComp</a></li><li><a href="global.html#displayWayPoints">displayWayPoints</a></li><li><a href="global.html#dmsToDecimal">dmsToDecimal</a></li><li><a href="global.html#drawGribLimits">drawGribLimits</a></li><li><a href="global.html#drawOrtho">drawOrtho</a></li><li><a href="global.html#drawPolyline">drawPolyline</a></li><li><a href="global.html#dumpRoute">dumpRoute</a></li><li><a href="global.html#feedback">feedback</a></li><li><a href="global.html#findBounds">findBounds</a></li><li><a href="global.html#findMaxSpeed">findMaxSpeed</a></li><li><a href="global.html#forWard">forWard</a></li><li><a href="global.html#formatDuration">formatDuration</a></li><li><a href="global.html#formatDurationShort">formatDurationShort</a></li><li><a href="global.html#formatLocalDate">formatLocalDate</a></li><li><a href="global.html#generatePolarPlotly">generatePolarPlotly</a></li><li><a href="global.html#getGreatCirclePath">getGreatCirclePath</a></li><li><a href="global.html#getParam">getParam</a></li><li><a href="global.html#getServerInit">getServerInit</a></li><li><a href="global.html#goBegin">goBegin</a></li><li><a href="global.html#gribInfo">gribInfo</a></li><li><a href="global.html#helpInfo">helpInfo</a></li><li><a href="global.html#interpolate">interpolate</a></li><li><a href="global.html#interpolateSpeeds">interpolateSpeeds</a></li><li><a href="global.html#latLonToStr">latLonToStr</a></li><li><a href="global.html#loadAppState">loadAppState</a></li><li><a href="global.html#loxoCap">loxoCap</a></li><li><a href="global.html#loxoDist">loxoDist</a></li><li><a href="global.html#manageCompetitors">manageCompetitors</a></li><li><a href="global.html#move">move</a></li><li><a href="global.html#oldshowContextMenu">oldshowContextMenu</a></li><li><a href="global.html#orthoCap">orthoCap</a></li><li><a href="global.html#orthoDist">orthoDist</a></li><li><a href="global.html#parDump">parDump</a></li><li><a href="global.html#polarInfo">polarInfo</a></li><li><a href="global.html#refreshMarker">refreshMarker</a></li><li><a href="global.html#removeCompetitor">removeCompetitor</a></li><li><a href="global.html#request">request</a></li><li><a href="global.html#resetWaypoint">resetWaypoint</a></li><li><a href="global.html#saveAppState">saveAppState</a></li><li><a href="global.html#setBoat">setBoat</a></li><li><a href="global.html#showContextMenu">showContextMenu</a></li><li><a href="global.html#showDestination">showDestination</a></li><li><a href="global.html#showInitMessage">showInitMessage</a></li><li><a href="global.html#showPOI">showPOI</a></li><li><a href="global.html#showPolarTable">showPolarTable</a></li><li><a href="global.html#showRoute">showRoute</a></li><li><a href="global.html#showRouteReport">showRouteReport</a></li><li><a href="global.html#showWayPoint">showWayPoint</a></li><li><a href="global.html#switchTab">switchTab</a></li><li><a href="global.html#symmetrizeData">symmetrizeData</a></li><li><a href="global.html#toDMSString">toDMSString</a></li><li><a href="global.html#updateAllBoats">updateAllBoats</a></li><li><a href="global.html#updateBindPopup">updateBindPopup</a></li><li><a href="global.html#updateBoatSelect">updateBoatSelect</a></li><li><a href="global.html#updateHeading">updateHeading</a></li><li><a href="global.html#updateIconStyle">updateIconStyle</a></li><li><a href="global.html#updateRouteDisplay">updateRouteDisplay</a></li><li><a href="global.html#updateStatusBar">updateStatusBar</a></li><li><a href="global.html#updateWindyMap">updateWindyMap</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sun Mar 23 2025 22:11:09 GMT+0100 (heure normale d’Europe centrale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
